# **AI 協調 UI 設計フレームワーク

コンセプトドキュメント（思想設計書 v1）**

本ドキュメントは、
AI と人間が協調して UI 設計を行うためのフレームワークを構築する際の
**思想・構造原則・設計哲学だけ** を記述したものです。

実装仕様、API 仕様、具体的なフォーマット、コーディング規約などは
後続の実装工程で本ドキュメントを元に定義されます。

---

# 1. フレームワークの目的（Purpose）

このフレームワークの最上位の目的は以下のとおり。

1. **AI と人間が安全かつ一貫性をもって UI 設計を編集できる世界をつくること**
2. **UI 設計（画面構造・イベント・I/F 仕様）を構造化データとして扱えるようにすること**
3. **設計フェーズと実装フェーズを完全に分離し、モック構造が実装を汚染しないようにすること**
4. **1つの計画の中で複数のサイト（公開サイト・管理サイト等）を扱える統一的な枠組みをつくること**
5. **AI に“誤解”させず正しい形式で設計書を操作させるためのドキュメント体系を持つこと**

---

# 2. UI 設計とは何か（Scope Definition）

本フレームワークが扱う「UI設計」は、以下の情報のみを対象とする。

* **レイアウト情報**

  * 画面の構造
  * 要素の配置
  * 情報構造（Screen → Area → Element）

* **画面項目の仕様**

  * 名前 / ラベル / 種別
  * 入力条件（桁数、バリデーションの存在など）
  * デザインの方向性などのメタ情報（目立つようになど）

* **イベント定義**

  * 画面内の操作（click, change 等）
  * 画面遷移（遷移先、条件など）

* **I/F（API）仕様**

  * 入出力データの概要
  * 画面が依存するデータモデル

対象外とする情報：

* CSS 等のデザイン
* ピクセル単位のレイアウト
* 実装コンポーネント構造（実装の正解は設計書には持たせない）

---

# 3. 設計データ構造の基本方針（Two Layer Model）

設計書の扱いは以下の二層構造で統一する。

### **一次ソース：YAML**

* 人間が読みやすい
* AI が編集しやすい
* コメントや意図を記述できる
* Git 差分が読みやすい

### **正規形式：JSON**

* バリデーションの対象
* バックエンド・SPAが扱う形式
* AI編集では JSON の差分更新も可能（API 経由）

**重要**
→ 「設計書は YAML を編集するが、フレームワーク内部では JSON が真実である」
→ 「YAML は編集のための媒体であり、解析のための媒体ではない」

---

# 4. プロジェクト構造（Project → Site → Screen）

本フレームワークは **3階層の構造モデル** を採用する。

```
Project（計画）
  └ Site（公開・管理など）
        └ Screen（画面単位）
```

### **4.1 Project（計画）**

* システム全体を表す単位
* 全サイト共通の情報・制約を持つ
* 設計書は `design/` 以下に集約する

### **4.2 Site（サイト）**

* 公開サイト / 管理画面 / パートナー向け 等
* サイトごとに固有の UI 原則・文脈を持つ
* 例えば：

  * 公開画面：シンプル、2カラム以内
  * 管理画面：データ密度高め、検索・一覧が中心

### **4.3 Screen（画面）**

* 画面単位の設計情報を保持
* レイアウト / 項目仕様 / イベント の3ファイルで構成
* 画面IDはサイト内で一意であればよい

### **4.4 設計書ディレクトリ構造**

```
design/
├── project.yaml           # プロジェクト設定
├── infrastructure.md      # インフラ情報（プロキシ設定等）
└── sites/
    └── {siteId}/
        ├── site.yaml          # サイト設定
        ├── interfaces.yaml    # サイト全体のI/F定義
        ├── _shared/           # 共通レイアウト・フィールド
        │   ├── app-layout.yaml
        │   └── app-fields.yaml
        └── screens/
            └── {screenId}/
                ├── layout.yaml    # 画面単位
                ├── fields.yaml
                └── events.yaml
```

---

# 5. 設計情報の分割原則

## 5.1 画面単位のファイル構成

1画面の設計情報は以下の **3つ** に分割する。

1. **layout（レイアウト構造）**
2. **fields（項目仕様）**
3. **events（イベント定義）**

これらの分割理由：

* ファイル単位の責務が明確になり、AI の編集精度が大幅に向上する
* 画面構造と動作仕様を分離できる
* プロジェクトの成長に伴い変更しやすい

## 5.2 サイト単位のファイル構成

I/F（API）仕様は **サイト単位で1ファイル** に集約する。

* **interfaces.yaml** - サイト全体のAPI定義

理由：

* I/Fはエンドポイントの集合であり、画面に紐付くものではない
* 同じAPIを複数画面で使用することが一般的
* エンドポイントの階層で自然に整理できる
* イベントからは `interfaceRef` で参照するだけ

## 5.3 共通レイアウトの継承（extends）

複数画面で共通のレイアウト構造（Header/Sidebar等）を持つ場合、
**extends** による継承を使用する。

```yaml
# _shared/app-layout.yaml（共通定義）
areas:
  - areaId: header
  - areaId: sidebar
  - areaId: main-content

# screens/dashboard/layout.yaml（画面固有）
extends: "_shared/app-layout"
mainContent:
  elements:
    - elementId: welcome-message
```

制約：

* 継承は **1段階のみ**（多段継承禁止）
* 共通レイアウトは `_shared/` ディレクトリに配置
* `mainContent` で画面固有のコンテンツを定義

---

# 6. 画面遷移は「イベント」として扱う

本フレームワークでは、画面遷移専用の定義ファイルは持たない。
理由は下記のとおり。

1. 遷移は UI の「動作」であり、イベントと同質
2. 二重管理を避ける（画面遷移表とイベント定義の不整合防止）
3. 画面遷移図はイベント定義から自動生成できる
4. AI に渡す設計ルールが減り、理解が簡単になる

つまり、下記のようにイベントの一種として表現する。

```
type: navigate
target: <screenId>
```

---

# 7. I/F定義の原則

## 7.1 I/Fはイベントからの参照先

I/F（API）定義は、画面の構成要素ではなく、
**イベントのアクションから参照されるエンドポイント定義** である。

```yaml
# events.yaml
- eventId: evt_login_submit
  actions:
    - type: api
      interfaceRef: "login"  # I/Fを参照

# interfaces.yaml（サイト単位）
login:
  method: POST
  path: "/api/auth/login"
```

## 7.2 内部APIと外部APIの区別

I/F定義では、以下のルールで内部/外部を区別する。

| 区分 | path の形式 | external フラグ | 意味 |
|------|------------|----------------|------|
| 内部 | 相対パス `/api/...` | 省略 or false | バックエンド実装が必要 |
| 外部 | 絶対URL `https://...` | true | 呼び出すだけ（実装不要） |

```yaml
# 内部API（実装が必要）
login:
  method: POST
  path: "/api/auth/login"

# 外部API（実装不要）
fetchWeather:
  method: GET
  path: "https://api.weather.com/v1/current"
  external: true
```

## 7.3 インフラ情報は別管理

リバースプロキシ設定や環境別エンドポイントなどの **インフラ情報** は、
UI設計書の範囲外とし、`design/infrastructure.md` で別途管理する。

理由：

* インフラ情報はサイト跨ぎの共通情報
* 環境（開発/本番）によって変わる可能性がある
* UI設計書は「フロントから見たパス」に集中すべき

---

# 8. AI 向けドキュメントの三層構造（Framework → Project → Site）

AI に誤った編集をさせないため、
ドキュメントは以下の **3階層モデル** で構成する。

---

## **8.1 Framework-level AI Docs（フレームワーク共通）**

内容：

* 設計スキーマ（layout / event / I/F）の構造
* AI が編集して良い・悪いファイル
* 形式上の厳密なルール
* フレームワークとしての思想
* 「モック構造は実装構造の指針にしてはいけない」などの禁止事項

役割：

> すべてのプロジェクトで必ず参照される、AIの“基本教科書”。

---

## **8.2 Project-level AI Docs（計画単位）**

内容：

* プロジェクト固有の命名規則
* 共通コンポーネントの先方針
* ドメイン用語、業務文脈
* プロジェクトのUI方針
* サイト横断での制約（例：公開サイトは2カラム以内）

役割：

> 「この計画はこういうUI思想で作るぞ」という文脈をAIに伝える。

---

## **8.3 Site-level AI Docs（サイト単位）**

内容：

* 公開/管理/パートナーなど、サイト固有の背景
* サイト固有の UI 方針
* 画面の基本テンプレート
* メニュー・ナビゲーションの概念
* よく出る用語・処理パターン

役割：

> 特定サイトの“ローカルルール”を AI に伝える。

---

# 9. 設計書ディレクトリは設定ファイルで解決する思想

本フレームワークでは
**「どこに設計書が置かれているか」** を開発者が意識する必要はない。

理由：

* プロジェクト構成の自由度を高めるため
* フレームワークが自動判定するべき責務のため
* AI との連携で「ファイルパス依存」を排除するため

プロジェクトはただ：

```
design/sites/public/
design/sites/admin/
```

のように置けばよく、
フレームワークは設定ファイルからパスを解決する。

---

# 10. 設計書と実装を切り離す思想

最重要ポイント。

本フレームワークでは：

* モックHTML
* 一時的なワイヤーフレームの DOM
* 画面表現のための簡易 HTML

など **実装に影響しうる構造情報は設計書に一切持ち込まない。**

理由：

1. AI が DOM 構造を「正解」と誤認し、実装に引きずられる
2. ワイヤーフレームの構造と React/Vue のコンポーネント構造は一致しない
3. 実装フェーズでは別の観点（再利用性・分割・状態管理）が必要
4. だから「UIの構造」はあくまで論理構造（Screen/Area/Element）で定義する

---

# 11. フレームワークが提供すべき"保証"と"世界観"

このフレームワークは以下を保証する必要がある。

### **11.1 保証**

* 設計書を AI が編集しても **破綻しない**
* 設計書がどこに置いてあっても **フレームワークが解決する**
* 複数サイトが存在しても **一貫した構造で表現できる**
* 設計書 → 実装 の流れで **責務が混ざらない**
* イベントと遷移が一元管理され、**画面遷移表が自動生成できる**
* YAML と JSON の二重構造が **整合性を保ったまま運用できる**

### **11.2 世界観（Vision）**

* 設計書は**コードではなく情報構造**
* 設計の管理は**コードから独立している**
* 設計ビューアは**閲覧専用で、実装を邪魔しない**
* AI は**フレームワークの思想に従って**設計を編集し、
  プロジェクト固有のルールにも従う
* 実装者は**意味情報だけを読み取り、自由にコンポーネントを設計できる**

---

# 結語

本ドキュメントは、実装工程の全員が初めに読むべき
**思想とコンセプトの共有資料**である。

ここに書かれた内容は仕様ではなく、**仕様の前に存在する“土台”**である。
実装フェーズではこの思想を絶対軸として、
具体的なスキーマ、API、ビューアの仕様化へ進む。
